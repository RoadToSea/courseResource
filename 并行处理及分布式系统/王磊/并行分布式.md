### C语言的三种并行拓展：MPI，Pthread， openMp



### 冯诺依曼体系结构（瓶颈）：

#### 瓶颈：主存与CPU之间分离

#### 解决方法：多通道，CPU缓存

#### CPU缓存：

##### 局部性原理：访问一个位置之后，紧接着是访问其附近的位置。

- **空间局部性（Spatial locality）**：访问临近的位置。
- **时间局部性（Temporal locality ）**：最近访问的位置，在不久的将来还会访问。

##### 缓存级别：

![image-20250104145911637](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250104145911637.png)

##### 缓存的命中与缺失

##### 缓存一致性问题：当CPU写数据到cache时，cache中的值可能与主存中的值不一致.

- 写直达：通过在写入到缓存时，更新主存中的数据来解决这个问题

- 写回：将缓存中的数据标记为**脏数据**。当缓存线（cache line ）被内存中的新缓存线替换时，**脏缓存线**

  被写入内存.

##### 缓存映射：

- **全相联：**一个新cache line可以放在缓存的任何位置
- **直接映射：**每一条高速缓存线在高速缓存中有一个唯一的位置，它将被分配到那里
- **n路相联：**每条高速缓存线可以被放置在**n**个不同的位置中的一个



### 并行硬件和软件：

### 任务并行数据并行：



### 多发技术：

#### 静态：计算单元在编译时被安排

#### 动态：功能单元在运行时被安排



### 弗林分类：SISD、SIMD、MIMD、MISD（主要前三个）

![image-20250104163137594](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250104163137594.png)

#### SIMD：

- 通过在处理器之间划分数据而实现的并行性

- 将相同的指令应用于多个数据项

- 叫做 **data parallelism**（数据并行）.

- 缺点：

  - 所有ALU都需要执行相同的指令，或者保持空闲状态.

  - 在经典设计中，它们还必须同步运行.

  - ALU不能进行指令存储.
  - 对于大型数据并行问题有效，但对于其它更复杂的并行问题无效。

#### MIMD:

- 支持多个数据流上同时运行多个指令流. 
- 通常由一组完全独立的处理单元或核心组成，每一个核心都有自己的控制单元（CU）和计算单元（ALU）。
- 

### 加速比 = 串行/并行时间

#### 

## 第一章：

![image-20250104135051994](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250104135051994.png)

[^重点]: 

#### 并行硬件和软件

##### 系统开发成本主要在于软件

[^重点]: 

#### 任务并行和数据并行

##### 协同：

核与核之间通常需要进行协同它们的任务

##### 通信：

一个或多个核将其当前的部分总和发送给另一个核

##### 负载均衡：

在内核之间均匀的分配工作，这样一个内核就不会负载过重

##### 同步：

因为每个核都有自己的工作节奏，所以要确保核不会比其他的核走得太远

#### 并行系统类型

##### 共享存储：

所有核可以共享计算机存储器的访问权限

通过内核检查核更新共享内存位置实现协同

##### 分布式存储：

每个核都有自己的私有内存

核必须通过网络发送消息进行显式通信，从而实现协同

#### 术语：

![image-20250104143133130](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250104143133130.png)

## 第二章

#### 缓存

#### 冯诺依曼体系结构



#### cache一致性:

##### 问题：程序员无法控制缓存何时更新

##### 解决方法：

1. 监听Cache一致性：
   - 多个核共享总线.
   - 在总线上传输的任何信号都可以被连接到总线的所有核“看”到.、
   - 当core 0更新存储在其Cache中的x的副本时，它也会通过总线广播该信息.
   - 如果core1正在“监听”总线，它将知道x已被更新，它将自己Cache中的x副本标记为非法的.
2. 基于目录的Cache一致性：
   - 使用一种称为目录的数据结构，该目录存储每个Cache line的状态.
   - 当一个变量被更新时，就会查询目录，并将所有包含该变量的cache line置为非法



#### 并行硬件（四种分类）



#### 性能（加速比几个概念）

##### 加速比：

- 核数 = p
- 串行程序运行时间= Tserial
- 并行程序运行时间= Tparallel
- 线性加速比：Tparallel = Tserial / p

##### 并行程序加速比：S = Tserial / Tparallel

##### 并行程序效率：E = S / P

##### 并行开销：Tparallel = Tserial / p + Toverhead



#### 编写程序的四个步骤（Forster方法：划分、通信、聚合，分配）

1. ##### 划分：将要执行的指令和数据按照计算拆分为多个小任务。

2. ##### 通信：确定前一步所识别出来的任务之间需要执行哪些通信。

3. ##### 聚集或聚合（Agglomeration or aggregation）:将第一步中确定的任务和通信合并成更大的任务。

4. ##### 分配（Mapping）:将上一步聚合好的任务分配给进程/线程.



#### 并行输出（不确定性）

- 竞争条件
- 临界区
- 互斥
- 互斥锁 (互斥量/锁)



## 第三章

#### MPI程序（基本的结构程序）

![image-20250104210903598](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250104210903598.png)



#### 派生数据类型

- 通过存储数据项的类型及其在内存中的相对位置，派生数据类型可以表示内存中数据项的任意集合

- 主要思想是，如果发送数据的函数知道有关数据项集合的信息，它可以在发送之前在内存中将数据项聚集起来.

- 类似地，接收数据的函数可以在数据项被接收后将数据项分发到它们在内存中的正确目标位置

- 形式上，由一系列基本MPI数据类型以及每个数据类型的偏移所组成

  - ![image-20250104211216832](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250104211216832.png)

    #### 														基本MPI数据类型

- 

#### 集合通信与点对点通信：

- 通信子中的所有进程必须调用相同的集合通信函数.
- 每个进程传递给 MPI 集合通信的参数必须是“相容的” 。
- output_data_p 参数只用在dest_process上.但是，所有的进程仍然需要传入一个与output_data_p对应的实参，即使它只是NULL.
- 点对点通信函数是通过标签和通信子来匹配
- 集合通信不使用标签
- 只通过通信子和调用的顺序来进行匹配



#### 广播：属于一个进程的数据被发送到通信子中的所有进程.

#### 聚集：将向量的所有分量收集到进程0上，然后进程0就可以处理所有的分量了。

#### 全局聚集（Allgather）：

- 将每个进程的send_buf_p的内容串联起来，存储到每个进程的recv_buf_p参数中.
- 通常，recv_count指每个进程接收的数据量

#### 并行排序和矩阵向量乘



## 第四章：

#### 4.8节（互斥、临界区、忙等待、伪共享）

#### 临界区：临界区是一个代码块，在这个代码块中，任意时刻只有一个线程能够更新共享资源。

#### 忙等待：在忙等待中，线程不停地测试某个条件，但实际上，直到某个条件满足之前，不会执行任何有用的工作.

#### 互斥量：

- 一个处于忙等待状态的线程仍然会持续地使用CPU，而什么也没有完成。
- 互斥量(互斥锁)是一种特殊类型的变量，它可以限制每次只允许一个线程访问临界区。
- 用于保证一个线程独享临界区，其它线程在有线程已经进入该临界区的情况下，不能同时进入。
- Pthreads标准为互斥提供了一种特殊的类型: pthread_mutex_t。

#### 伪共享：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。

## 第五章：

#### 基本openMp结构

#### 规约：

- 归约操作符是一种二元操作(如加法或减法)
- 规约是一种重复地对操作数序列，应用相同的归约操作符以获得单个结果的计算
- 所有操作的中间结果都应该存储在同一个变量中:归约变量.

## 编程题：

规约、矩阵乘（API）