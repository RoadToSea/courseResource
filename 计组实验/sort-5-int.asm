 .text
#################################################################################
#本程序实现（字节地址0x200，字地址0x80）开始的8个字单元的降序排序,此程序可在mars mips仿真器中运行,运行时请将Mars Setting中的Memory Configuration设置为Compact，data at address 0
#中断服务程序1将字地址0x90开始的8个字数据累加1
#中断服务程序2将字地址0xa0开始的8个字数据累加-1
##################################################################################
 .text
sort_init:	#设置排序原始数据，从字节地址512单元（字地址128，即0X80）开始依次存放-1,1,2,3,4,5,6
 addi $s0,$0,-1		#s0=-1，0号寄存器中的值送ALU计算，其本身的值没变，还是初始值0，单步调试可以验证。
 addi $s1,$0,0		#S1=0
 sw $s0,512($s1)	#512单元=-1
 addi $s0,$s0,1		#s0=0
 addi $s1,$s1,4		#s1=4
 sw $s0,512($s1)	#516单元=0
 addi $s0,$s0,1		#s0=1
 addi $s1,$s1,4		#s1=8
 sw $s0,512($s1)	#520单元=1
 addi $s0,$s0,1
 addi $s1,$s1,4
 sw $s0,512($s1)    #524单元=2
 addi $s0,$s0,1
 addi $s1,$s1,4
 sw $s0,512($s1)	#528单元=3
 addi $s0,$s0,1
 addi $s1,$s1,4
 sw $s0,512($s1)	#532单元=4
 addi $s0,$s0,1
 addi $s1,$s1,4
 sw $s0,512($s1)	#534单元=5
 addi $s0,$s0,1
 addi $s1,$s1,4
 sw $s0,512($s1)	#536单元=6
 
 addi $s0,$zero,0	#s0=0
 addi $s1,$zero,28   #排序区间  s1=28，地址指针偏移S1=28
sort_loop:			
#打擂台法，从512单元开始取数据，与从后到前的数据依次比较，大数放入512单元。

 lw $s3,512($s0)	#从512单元读1个数据到S3  
 lw $s4,512($s1)	#从最后一个未比较的540,536。。。单元读1个数到s4
 slt $t0,$s3,$s4	#比较两个读入数据大小，S3小于S4则T0=1，否则T0=0
 beq $t0,$0,sort_next   #降序排序。前面数（512单元中的数）大，S3>s4则直接转sort_next（此时512单元存大数，当前指针S1指向单元存小数）

 #512单元中的数如果小，则交换，大数放入512，小数放入S1指向单元

 sw $s3, 512($s1)		#如果，S3<S4,则小数S3放入S1指向的内存单元。
 sw $s4, 512($s0)		#大数S4放入512单元单元，即大数放在512单元
sort_next:              #继续比较下一个数
 addi $s1, $s1, -4		#地址指针偏移S1-4 指针变为536（指向从后往前的前一个数）
 beq $s0, $s1,  sort_next1  #指针S1是否=S0，即S0中的数是否遍历比较完全部数据，=0，比较完则跳转到sort_next1结束本轮遍历比较。
 beq $0,$0,sort_loop		#未比较完，则跳回sort_loop512单元数据继续守擂。相当于绝对转移，CPU无绝对转移指令。
sort_next1:
 addi $s0,$s0,4		#指针+1指向下一个数		
 addi $s1,$zero,28	#指针S1恢复，指向最后一个数
 beq $s0, $s1, ProgramEnd  #是否比较完全部数据（遍历次数是否完成？），完成，则跳到死循环结束。
 beq $0,$0,sort_loop		#未完成遍历次数，则重新开始下一轮遍历比较
 ProgramEnd:beq $0,$0,ProgramEnd  #死循环
  
IntProgram1:
  addi $sp,$sp,8    #push registers  需要保留哪些寄存器？ 中断程序用到的寄存器，初始化中断指针SP，当前SP+8
  sw $s0,0($sp)     #保存现场，保存S0寄存器
  sw $s1,4($sp)     #保存现场，保存S1寄存器

  addi $s1,$0,0x240
  lw $s0,($s1)	#S1指向的内存单元中的值送入S0
  addi $s0,$s0,1	#s0寄存器中的值加1（即S1指向的内存单元中的值+1）
  sw $s0,($s1)	#向s1指向的内存单元存入其+1后的值，以下一次在连续的8个字单元中存入相同的值
  sw $s0,4($s1)
  sw $s0,8($s1)
  sw $s0,12($s1)
  sw $s0,16($s1)
  sw $s0,20($s1)
  sw $s0,24($s1)
  sw $s0,28($s1)
  lw $s1,4($sp)   #pop registers，恢复现场
  lw $s0,0($sp)
  addi $sp,$sp,-8	#恢复SP
  eret		#中断返回
IntProgram2:
  addi $sp,$sp,8    #push registers  需要保留哪些寄存器？ 中断程序用到的寄存器
  sw $s0,0($sp)
  sw $s1,4($sp)

  addi $s1,$0,0x280
  lw $s0,($s1)
  addi $s0,$s0,-1
  sw $s0,($s1)
  sw $s0,4($s1)
  sw $s0,8($s1)
  sw $s0,12($s1)
  sw $s0,16($s1)
  sw $s0,20($s1)
  sw $s0,24($s1)
  sw $s0,28($s1)
  
  lw $s1,4($sp)   #pop registers
  lw $s0,0($sp)
  addi $sp,$sp,-8
  eret

