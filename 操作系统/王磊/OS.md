[toc]

### 进程同步的基本概念

**临界资源：一段时间仅允许一个进程访问的资源。临界资源可能是硬件，也可能是软件：变量、数据、表格、队列等**

**临界区：临界段，在每个程序中，访问临界资源的那段程序**

**注意：临界区是对某一临界资源而言的，对于不同临界资源的临界区，他们不存在互斥**

**同步机制应遵循的规则：**

- **空闲让进**
- **忙则等待**
- **有限等待**

- **让权等待**

**进程间的基本关系为：同步与互斥**

### 信号量机制

**整型信号量：把整型信号量定义为一个整型量**

**由两个标准原子操作 wait(S)（P操作）和 signal(S)（V操作）来访问**

**两种操作均为原语操作**

```c
wait(S):	while S <= 0 do no-op;
			S:=S-1;

signal(S):	S:=S+1;
```



---



**记录型信号量**

**记录型信号量机制采取“让权等待”策略，避免了整型信号量出现的“忙等”现象**

**实现时需要一个用于代表资源数目的整型变量value,一个用于链接所有阻塞进程的进程链表queue.**

**信号量是一个数据结构，定义如下：**

```c
struct semaphore
{
    int value;
    pointer_PCB queue;
}

// 信号量说明
semaphore s;
```

**P操作**

```c
P(s)
{
	s.value = s.value - 1;
    if (s.value < 0)
    {
        // 该进程状态置为阻塞状态
        // 将该进程的PCB插入相应的阻塞队列末尾s.queue;
    }
}
```

**V操作**

```c
V(s)
{
    s.value = s.value + 1;
    if (s.value <= 0)
    {
        /* 唤醒相应阻塞队列s.queue中阻塞的一个进程
           改变其状态为就绪状态，并将其插入就绪队列 */ 
    }
}
```



---



**AND信号量**

**AND同步机制的基本思想是：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要有一个资源未分配给进程，其他所有可能为之分配的资源，也不分配给它。**

**AND型信号量**

```c
Swait(S1, S2, ..., Sn)
    if S1 >= 1 and ... and Sn >= 1 then
        for i:= 1 to n do
            Si: = Si - 1;
		endfor
    else
        // 当发现有 S1 < 1时，
        // 该进程状态置为阻塞状态
    endif
        
        
Ssignal(S1, S2, ...,Sn)
        for i:= 1 to n do
            Si:= Si + 1;
			// 将与Si相关的所有阻塞进程移出到就绪队列
		endfor
```

![](https://s3.ananas.chaoxing.com/doc/2b/c4/9e/cfbf8e9edc5e4f43a831d147f2525a08/thumb/11.png)

![](https://s3.ananas.chaoxing.com/doc/2b/c4/9e/cfbf8e9edc5e4f43a831d147f2525a08/thumb/12.png)

**缺点：**

**一次需要N个某类临界资源时，就要进行N次P操作——低效又可能死锁**



---



**信号量集**

**信号量集是指同时需要多种资源、每种占有的数目不同、且可分配的资源还存在一个临界值时的信号量处理。**

**一般信号量集的基本思想就是在AND型信号量的基础上进行扩充，在一次原语操作中完成所有的资源申请。**

![](https://s3.ananas.chaoxing.com/doc/2b/c4/9e/cfbf8e9edc5e4f43a831d147f2525a08/thumb/14.png)

![](https://s3.ananas.chaoxing.com/doc/2b/c4/9e/cfbf8e9edc5e4f43a831d147f2525a08/thumb/15.png)

![](https://s3.ananas.chaoxing.com/doc/2b/c4/9e/cfbf8e9edc5e4f43a831d147f2525a08/thumb/16.png)

**一般“信号量集”可以用于各种情况的资源分配和释放，几种特殊情况：**

- **Swait(S, d, d) 表示每次申请d个资源，当少于d个资源时，便不分配**

- **Swait(S, 1, 1) 表示记录型信号量或互斥信号量**
- **Swait(S, 1, 0) 可作为一个可控开关（当S >= 1时，允许多个进程进入特定区域；当S = 0时，禁止任何进程进入该特定区域）**
- **一般“信号量集”未必成对使用。如：一起申请，但不一起释放。**



---



**利用信号量实现进程互斥**

- **只需为临界资源设置一互斥信号量 mutex,设其初始值为1；**

- **将各进程访问该临界资源的临界区CS置于wait(mutex) 和 signal(mutex)操作之间即可**

  

![](https://s3.ananas.chaoxing.com/doc/2b/c4/9e/cfbf8e9edc5e4f43a831d147f2525a08/thumb/21.png)



---



**利用信号量实现前趋关系**

**方法1：**

- **在需要顺序执行的进程（P1 -> P2）间设置一个公用信号量S（标识后面的进程是否可以开始运行），供两个进程共享，并赋初值为0**

- **在进程P1中，运行...，signal(S)**
  **在进程P2中，wait(S)，运行...**

**方法二**

- **在需要顺序执行的进程（P1 -> P2）间设置一个同步信号量f,用来标识前面进程是否执行完成，并赋初始值为0**
- **在进程P1中，运行...，signal(f)**
  **在进程P2中，wait(f)，运行...**



---



**进程同步问题**

**由于有界缓冲区是一个临界资源，必须互斥使用，所以还需要设置一个互斥信号量mutex,其初值为1**

**为解决生产者消费者问题，可以设两个同步（资源）信号量：**

- **一个代表空缓冲区的数目，用empty表示，初值为有界缓冲区的大小n**

- **一个代表已用缓冲区的数目，用full表示，初值为0**

**问题的解**

**生产者：**

```c
i = 0;
while (1)
{
    // 生产产品
    P(empty);
    P(mutex);
    // 往Buffer[i]放产品
    i = (i + i) % n;
    V(mutex);
    V(full);
}
```

**消费者：**

```c
j = 0;
while (1)
{
    P(full);
    P(mutex);
    // 从Buffer[j]取产品
    j = (j + 1) % n;
    V(mutex);
    V(empty);
    // 消费产品
}
```

**注意：**

- **mutex的PV操作在一个进程中必须成对出现，且分别作为进入区和退出区**
- **empty的P操作和full的V操作必须在同一进程成对出现**

- **empty、full各自的PV操作也必须都存在，但出现在不同的进程中**

- **资源信号量的P、V操作应在互斥信号量的P、V操作的外侧！**



---



**采用AND型信号量解决生产者消费者问题**

**生产者：**

```c
i = 0;
while (1)
{
    // 生产产品
    Swait(empty, mutex);
    // 往Buffer[i]放产品
    i = (i + 1) % n;
    Ssignal(mutex, full);
}
```

**消费者：**

```c
j = 0;
while (1)
{
    Swait(full, mutex);
    // 从Buffer[j]取产品
    j = (j + 1) % n;
    Ssignal(mutex, empty);
    // 消费产品
}
```



---



**读者 / 写者问题**

**有两组并发进程：读者和写者，共享一组数据区**

**要求：**

- **允许多个读者同时执行读操作**
- **不允许读者、写者同时操作**
- **不允许多个写者同时操作**

**问题分析：**

- **读者来：**

  - **无读者、写者，新读者可以读**

  - **有读者在读，则新读者也可以读，无论有无写者等待**

  - **有写者写，则新读者等待**

- **写者来：**

  - **无读者、写者，新写者可以写**
  - **有读者，新写者等待**
  - **有其他写者，新写者等待**

**读写者问题解法：**

- **`w`用于读者和写者、写者和写者之前的互斥**
- **`readcount`表示正在读的读者数目**
- **`mutex`用于对`readcount`这个临界资源的互斥访问**
- **设一个全局变量`readcount = 0`，设有两个信号量`w = 1`，`mutex = 1`**
- **仅当`readcount = 0`，读者进程才需要和执行`wait(w)`，同时`readcount + 1`**
  - **如果有写者写，就不允许读者读**
  - **只要有一个读者在读，便不允许写者去写**
- **仅当`readcount - 1`后其值为`0`时，读者进程才需要执行`signal(w)`，以便让写者写**



**读者：**

```C
while (1)
{
    P(mutex);
    if (readcount == 0)
        P(w);
    readcount++;
    V(mutex);
    // 读
    P(mutex);
    readcount--;
    if (readcount == 0)
        V(w);
    V(mutex);
}
```

**写者：**

```c
while (1)
{
    P(w);
    // 写
    V(w);
}
```



---



**哲学家就餐问题**

- **叉子为临界资源**
- **为每一把叉子设置一个信号量，用数组fork[i]表示，初始值为1**

- **防止死锁发生的措施**
  - **仅当一个哲学家左右两边的叉子都可以用时，才允许他拿叉子**

**采用AND信号量解决哲学家就餐问题**

```c
Philosopher i:
while (1)
{
    // 思考
    Swait(fork[i], fork[(i + 1) % 5]);
    // 进餐
    Ssignal(fork[i], fork[(i + 1) % 5]);
}
```

**无死锁哲学家就餐问题 解1**

- **设fork[5]为5个信号量，初值均为1**
- **设有全局变量Count初值为0**
- **设信号量Mutex、W,初值为1**
- **W用于封锁第五个哲学家**
- **Mutex用于对临界资源Count的访问**

```c
Philosopher i:
while (1)
{
    // 思考
    P(Mutex);
    Count++;
    if (Count >= 4)
        P(W);
    V(Mutex);
    
    P(fork[i]);
    P(fork[(i + 1) % 5]);
    // 进餐
    V(fork[i]);
    V(fork[(i + 1) % 5]);
    
    P(Mutex);
    Count--;
    if (Count == 3)
        V(W);
    V(Mutex);
}
```

**无死锁哲学家就餐问题 解2**

- **设fork[5]为5个信号量，初值均为1**
- **设信号量S,用于封锁第五个哲学家，初值为4**

```c
Philosopher i:
while (1)
{
    // 思考
    P(S);
    P(fork[i]);
    P(fork[(i + 1) % 5]);
    // 就餐
    V(fork[i]);
    V(fork[(i + 1) % 5]);
    V(S);
}
```



### 管程机制

**管程的基本概念**

- **引入原因：可以减少大量的同步操作分散在各个进程中。**
- **解决办法——引入管程**
  - **为每个可共享资源设立一个专门的管程来统一管理各进程对该资源的访问**

**管程的定义**

- **一个管程包含一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变进程中的数据**

**管程的三个部分**

- **局部于管程的共享变量说明**
- **对该数据结构进行操作的一组过程**
- **对局部于管程的数据设置初始值的语句**

**管程的特点**

- **局部数据变量只能被管程的过程访问，任何外部过程都不能访问**
- **一个进程通过调用管程的一个过程进入管程**
- **在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都会被挂起，以等待管程变成可用的。**

**条件变量**

- **管程内部的同步机制**
- **每个条件变表示一种等待原因，对应一个等待队列**
- **可执行wait和和signal两种操作，且应置于wait和signal之前，如x.wait,x.signal**
  - **Wait() 操作**
    - **将自己阻塞在等待队列中**
    - **唤醒一个等待者或释放管程的互斥访问**
  - **Signal() 操作**
    - **将等待队列中的一个线程唤醒**
    - **如果等待队列为空，则等同空操作**



---



**利用管程解决生产者——消费者问题**

- **建立管程PC**
- **$\color{red}{put(item)过程 将生产的产品投放到缓冲池中，并用整型变量count来表示缓冲池中已有的产品数目，当count >= n 时，表示缓冲池已满，生产者需等待}$**
- **get(item) 过程 从缓冲池中取走一个产品，当count <= 0 时，表示缓冲池空，消费者需等待**



### 进程通信类型

- **所谓进程通信是指进程之间信息交换**
- **P、V操作实现的是进程之间的低级通信，所以P、V为低级通信原语，它只能传递简单的信号，不能传递大量信息**
- **如果要在进程间传递大量信息，可以用Send / Receive原语（高级通信原语）**



1. **共享存储器系统**
   - **基于共享数据结构的通信方式**
   - **基于共享存储区的通信方式**
     - **以上两种方式的同步互斥都要由进程自己负责**
     - **共享存储器系统：**
       - **最快的方法**
       - **一个进程写另外一个进程立即可见**
       - **没有系统调用干预**
       - **没有数据复制**
       - **不提供同步**
2. **消息传递系统**
   - **进程间的数据交换以消息为单位，程序员利用系统的通信原语实现通信**
   - **消息传递系统可分为：**
     - **直接通信：发送进程直接把消息发送给接收者，并将它挂在接收进程的消息缓冲队列上。接收进程从消息缓冲队列中取得消息（也称为消息缓冲通信）**
     - **间接通信：发送进程将消息发送到某种中间实体中（信箱），接收进程从中取得消息（也称信箱通信）**
   - **直接通信和间接通信方式的主要区别**
     - **前者需要两进程都存在，后者不需要**
   - **进程间用信件传递信息时，信件中应包含$\color{red}{信箱名}$**
   - **利用信箱通信时，在发送进程和接收进程间，存在以下4种关系：**
     - **一对一关系**（发送进程和接收进程可以建立一条两者专用的通信链路，使两者间的交互不受其他进程的干扰）
     - **多对一关系**（允许提供服务的进程与多个用户进程进行交互，也称客户 / 服务器交互）
     - **一对多关系**（允许一个发送进程与多个接收进程进行交互，使发送进程可用广播方式向接收者（多个）发送消息）
     - **多对多关系**（允许建立一个公用信箱，使得多个进程既能向信箱中投递消息，又能从信箱中取走属于自己的消息）
3. **管道（Pipe）通信（共享文件方式）**
   - 管道是最初的UNIX IPC 形式，**能传输大量数据**
   - **管道是指用于连接一个读进程和一个写进程的文件，称pipe文件**
   - 向管道提到输入的进程（**称写进程**），以**字符流的形式（先进先出）**将大量数据送入管道，接收管道输出的进程（**读进程**）可从管道中接收数据
   - 管道可以是**单工**的，也可以是**双工**的
   - 管道分为**无名管道**和**有名管道**
   - **$\color{purple}{管道和消息队列的区别：}$**
     - **$\color{purple}{管道是外存的，消息队列是内存的}$**
     - **$\color{purple}{管道中消息是无界的}$**
4. **客户机 / 服务器方式**

### 消息传递系统实现

**间接通信方式**

- **信箱的创建与撤销**
- **信箱中消息的发送与接收**
- 信箱使用规则
  - 若发送信件时信箱已满，则**发送进程被置为“等信箱”状态**，直到信箱有空时才被唤醒
  - 若取信件时信箱中无信，则**接收进程被置为“等信件”状态**，直到有信件时才被唤醒

**信箱的种类**

- **私用信箱**
  - **用户进程**为自己**创建**的信箱，是进程的一部分
  - **只有自己有权读**，可采用单向链路实现
- **公用信箱**
  - 由**操作系统创建**，所有系统核准进程都可以使用，**采用双向通信链路实现**
- **共享信箱**
  - 由某进程创建并指明可共享，则**拥有者和共享者可以使用**

**Send实现**

- **$\color{red}{send(MailBox, M)：}$**把信件M送到指定信箱中去
- **步骤：**
  - 查找指定信箱
  - 若信箱未满，则送入信件且唤醒“等信件者”
  - 如信箱已满，置发送信件进程为“等信箱”状态

**Receive实现**

- **$\color{red}{receive(MailBox, X)：}$**从指定信箱中取出一封信，存放到指定的地址X中
- **步骤：**
  - 查找指定信箱
  - 若信箱中有信，则取出一封存于X中且唤醒“等待信箱”者
  - 若信箱中无信件，置接收信件进程“等信件”状态

**通信链路**

- **通信链路的分类**
  - 根据**连接方法**，可分**点 — 点连接通信链路**和**多点连接链路**
  - 根据**通信方式**不同，可分为**单向通信链路**和**双向链路**
  - 根据**链路容量**不同，可分为**无容量通信链路**和**有容量通信链路**

![](https://s3.ananas.chaoxing.com/sv-w2/doc/3f/83/4a/2146a2543c4981f8a862fbc048ef576e/thumb/14.png)

![](https://s3.ananas.chaoxing.com/sv-w2/doc/3f/83/4a/2146a2543c4981f8a862fbc048ef576e/thumb/19.png)

- **每个缓冲区只要写一次但要读n<sub>2</sub>次，因此可以看成n<sub>2</sub>组缓冲区，每个发送者要同时写n<sub>2</sub>组缓冲区中对应的n<sub>2</sub>个缓冲区，而每个接收者只要读它自己对应的那组缓冲区的对应单元**
- **Sin[n<sub>2</sub>] = m，表示每组缓冲区中可放的（空）缓冲区数目，初值为m**
- **Sout[n<sub>2</sub>] = 0，表示每组缓冲区中可取的（已用的）缓冲区的数目，初值为0**

```c
Ai:
while(1)
{
    for(int i = 0; i < n2; ++i)
    {
        P(Sin[i]);
    }
    P(mutex);
    // 将数据放入缓冲区
    V(mutex);
    for(int i = 0; i < n2; ++i)
    {
        V(Sout[i]);
    }
}

Bi:
while(1)
{
    P(Sout[i]);
    P(mutex);
    // 从缓冲区取走数据
    V(mutex);
    V(Sin[i]);
}
```



### 线程

**线程的引入**

- **$\color{green}{进程引入目的：}$使多个程序并发执行，以改善资源利用率、提高系统吞吐量**
  - **$\color{green}{进程是一个拥有资源的基本单位}$**
  - **$\color{green}{进程是一个独立调度的基本单位}$**
- **$\color{purple}{线程引入目的：}$减少程序并发执行时的付出的时空开销**

**线程的描述**

- 线程是进程中的一个实体，**是被系统独立调度**和分配的**基本单位**
- 线程**基本不拥有系统资源**，只拥有少量必不可少的资源：程序计数器、一组寄存器

- 线程可与**同属一个进程的其它线程共享**进程所拥有的全部资源
- 一个线程可以**创建**和**撤销**另一个线程
- **同一进程**中的**多个线程之间**可以**并发执行**
- **线程之间是无保护的**

**线程与进程的比较**

- 在引入线程的OS中，每一进程都拥有多个线程，至少一个
- 线程具有进程的许多特征，故又称**轻型进程**，传统进程称**重型进程**
- **调度**
  - 传统OS：**进程是拥有资源、独立调度和分配的基本单位**
  - 引入线程的OS：**线程是调度和分配的基本单位，进程是拥有资源的基本单位**
  - 一个进程内线程切换不会产生进程切换，由一个进程内的线程切换到另一个进程内的线程时，将会引起进程的切换
- **并发性**
  - 引入线程的OS：
    - **进程间可并发，同一进程内的各线程之间也能并发执行**，因而系统具有更好的并发性
- **拥有资源**
  - 无论是传统OS还是引入线程的OS，**进程都是拥有资源的独立单位**（**$\color{purple}{一个进程的所有资源可供进程内的所有线程共享}$**）
- **系统开销**
  - **$\color{purple}{进程的创建、撤销、切换开销要远大于线程的创建、撤销、切换开销}$**
  - 同一进程内各**线程**由于它们拥有相同的地址空间，它们之间的**同步和通信的实现**也变得**比较容易**

**用户级线程和内核支持线程**

- **内核支持线程**
  - 依赖于内核，无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤销、切换都由内核实现
- **用户级线程**
  - 这种线程的创建、撤销、切换都不用系统调用，**内核不知道用户级线程的存在**

- **用户级线程的优点和缺点**
  - **优点：**
    - **线程切换不调用核心**
    - **调度是应用程序特定的（可以选择最好的算法）**
    - **可运行在任何操作系统上（只需要线程库），可在一个不支持线程的OS上实现**
  - **缺点：**
    - 大多数系统调用是阻塞的，因此核心阻塞进程，故进程中所有线程将被阻塞
    - **核心只能将处理器分配给进程，同一进程中的两个线程不能同时运行在两个处理器上**

- **核心级线程的优点和缺点**
  - **优点：**
    - 对**多处理器**，核心可以**同时调度同一进程的多个线程**
    - 阻塞是在**线程**一级完成
  - **缺点：**
    - **在同一进程内的线程切换调用内核，导致速度下降**

- **$\color{purple}{为什么每个线程都必须有自己的堆栈资源？}$**
  - **$\color{green}{线程是独立执行的，线程执行时需要的资源保存在栈中，为了线程不互相干扰，它们存放资源的堆栈是独立的}$**### 处理机调度与死锁

### 处理机调度概述

- **处理机调度的三个层次**

  - **高级调度**
    - **决定把外存上哪些作业调入内存、创建进程、分配资源**
    - **又称作业调度、长程调度或宏观调度**
    - **$\color{red}{只在批处理系统中有高级调度}$**
  - **低级调度**
    - **决定就绪队列中哪个进程应获得处理机**
    - **又称进程调度、短调度或微观调度**
    - **$\color{red}{高效、不宜复杂、任何操作系统都有}$**
  - **中级调度**
    - **$\color{red}{主要目标是提高内存利用率和吞吐量}$**
    - **完成进程的部分或全部在内、外存间的交换**
    - **又称中程调度**

- **选择调度算法和调度方式的目标**

  - **共同目标**
    - **资源利用率高**
    - **$\color{red}{CPU的利用率 = CPU有效工作时间 / (CPU有效工作时间 + CPU空闲等待时间)}$**
    - **公平性**
    - **资源的平衡利用**
    - **策略的强制执行**

- **$\color{red}{批处理系统的目标}$**

  - **周转时间短**

    - 假定某一作业**提交系统时间为S<sub>i</sub>**，它被选中执行，**运行结束时间为E<sub>i</sub>**，**周转时间T<sub>i</sub> = E<sub>i</sub> - S<sub>i</sub>**，作业**平均周转时间为： （$\color{red}{衡量不同调度算法对相同作业流的调度性能}$）**
      $$
      T = \displaystyle \frac{1}{n}\sum^{n}_{i = 1}{T_i}
      $$

    - **带权周转时间是指作业的周转时间与系统为它提供的服务的时间之比。（反映作业（或进程）的长短）$\color{red}{带权周转时间越大，作业越短，带权周转时间越小，作业越长。}$（$\color{green}{调度算法的评价标准之一}$）**
      
    - **平均带权周转时间为：T<sub>i</sub>为作业周转时间，T<sub>si</sub>为系统服务时间$\color{red}{衡量调度算法对不同作业流调度性能}$**

    $$
    W = \displaystyle \frac{1}{n}\sum^{n}_{i = 1}\displaystyle \frac{T_{i}}{T_{si}}
    $$

  - **CPU利用率高**
  - **系统吞吐量高（系统吞吐量指在单位时间内系统完成的作业数）**

- **$\color{red}{分时系统的目标}$**

  - **响应时间快**（用户通过键盘提交一个请求开始，直至系统首次响应为止的时间）

  - **均衡性**

- **$\color{red}{实时系统的目标}$**
  - **截止时间的保证**
  - **可预测性准则**
- **$\color{red}{作业调度程序从处于}$ $\color{green}{收容状态}$的作业中选取一个作业并把它装入主存**
- **$\color{red}{由新建状态转换为就绪状态的调度方式是}$ $\color{green}{长程调度}$**
- **$\color{red}{评价调度算法，从系统的角度，更关注的是}$ $\color{green}{吞吐量和CPU利用率}$**
- **$\color{green}{长程调度}$ $\color{red}{决定哪个进程可以进入系统中处理，因此它控制了并发的度}$**



### 作业调度

- **作业调度的主要决策**

  - 接纳多少个作业：**取决于系统多道程序度**
  - 接纳哪些作业：**取决于系统的调度算法：（先来先服务、短作业优先、优先级调度算法）**

- **$\color{red}{先来先服务调度算法（FCFS）}$**

  - 选择一个或多个**$\color{red}{最先}$进入后备队列的作业，将它们调入内存，为它们分配资源、创建进程，并放入$\color{red}{就绪队列}$**
  - **特点：**
    - **$\color{red}{有利于长作业，不利于短作业}$**
    - **$\color{red}{有利于CPU密集 / 繁忙型的作业，不利于I / O密集 / 繁忙型的作业}$**
    - **$\color{red}{几乎所有的进程都交替出现计算和I / O请求}$**

- **$\color{red}{短作业优先调度算法（SJF、SPF）}$**

  - 在后备队列选择一个或多个估计运行时间**$\color{red}{最短}$**的作业，调入内容，为它们分配资源、创建进程、**$\color{red}{并放入就绪队列}$**

  - **特点：**

    ![image-20221205110817375](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221205110817375.png)

    - **平均周转时间为 (4a + 3b + 2c + d) / 4**
    - **$\color{red}{a对平均周转时间影响最大，应为短作业，其次是b，c，d}$**
    - **优点：**
      - **$\color{red}{能有效地降低作业的平均等待时间，提高系统吞吐量}$**
    - **缺点：**
      - **$\color{red}{对长作业不利，未考虑作业紧迫程度，作业的估计运行时间不准确}$**

- **$\color{red}{优先级调度算法（PSA）}$**

  - 在后备队列选择一个或多个**$\color{red}{优先级最高}$**的作业，将其调入内存，为它们分配资源、创建进程，并放入就绪队列。
  - **$\color{red}{高响应比优先调度算法（HRRN）}$**
    - **$\color{red}{响应比Rp = 作业响应时间 / 作业要求服务时间 = (作业要求服务时间 + 作业等待时间) / 作业要求服务时间 = 1 + （作业等待时间 / 作业要求服务时间）}$**
    - 作业等待时间相同，则处理时间越短，响应比越高，有利于短作业
    - 对于长作业，随等待时间增加，响应比增高，最后同样可获得处理机
    - 处理时间相同，等待时间越长，响应比越高，实现的是先来先服务

**先来先服务**

| 作业名 | 到达时间 | 处理时间 | 开始时间 | 结束时间 | 周转时间 | 带权周转时间 |
| ------ | -------- | -------- | -------- | -------- | -------- | ------------ |
| A      | 0        | 3        | 0        | 3        | 3        | 1            |
| B      | 2        | 6        | 3        | 9        | 7        | 1.17         |
| C      | 4        | 4        | 9        | 13       | 9        | 2.25         |
| D      | 6        | 5        | 13       | 18       | 12       | 2.4          |
| E      | 8        | 2        | 18       | 20       | 12       | 6            |

平均周转时间：8.6

平均带权周转时间：2.664

**短作业优先算法**

| 作业名 | 到达时间 | 处理时间 | 开始时间 | 结束时间 | 周转时间 | 带权周转时间 |
| ------ | -------- | -------- | -------- | -------- | -------- | ------------ |
| A      | 0        | 3        | 0        | 3        | 3        | 1            |
| B      | 2        | 6        | 3        | 9        | 7        | 1.67         |
| C      | 4        | 4        | 11       | 15       | 11       | 2.75         |
| D      | 6        | 5        | 15       | 20       | 14       | 2.8          |
| E      | 8        | 2        | 9        | 11       | 3        | 1.5          |

平均周转时间：7.6

平均带权周转时间：1.944

**高响应比优先调度算法**

| 作业名 | 到达时间 | 处理时间 | 开始时间 | 结束时间 | 周转时间 | 带权周转时间 |
| ------ | -------- | -------- | -------- | -------- | -------- | ------------ |
| A      | 0        | 3        | 0        | 3        | 3        | 1            |
| B      | 2        | 6        | 3        | 9        | 7        | 1.67         |
| C      | 4        | 4        | 9        | 13       | 9        | 2.25         |
| D      | 6        | 5        | 15       | 20       | 14       | 2.8          |
| E      | 8        | 2        | 13       | 15       | 7        | 3.5          |

平均周转时间：8

平均带权周转时间：2.244



### 进程调度

**进程调度的任务**

- **保存处理机的现场信息**
- **按某种调度算法选取进程**
- **把CPU分配给进程**（由分派程序把CPU分配给该进程，设置选中进程的处理机现场信息，交处理机控制权给进程运行）

**进程调度方式**

- **非抢占式：**不允许某进程抢占已经分配出去的处理机
- **抢占方式：**允许调度程序根据某种原则，暂停正在执行进程，将处理机重新分配给另一进程。（**优先权原则、短进程优先原则、时间片原则**）

**低级调度时机**

- 当一个**进程运行完毕**或因为出错等原因而**终止运行**会导致调度新的进程执行，会发生低级调度
- **等待I / O**

- **执行了某种原语操作（P操作，阻塞原语）**

- **时间片到**
- **优先级更高的进程就绪（可抢占式）**



**$\color{red}{短进程优先调度算法}$**

- **$\color{red}{最短剩余时间（SRT）}$**

- 是对SPF增加了**$\color{red}{抢占机制}$**的版本（有新的进程就绪，且新进程的服务时间小于当前进程的剩余时间，转到新进程执行）

- 调度程序总是选择预期剩余时间最短的进程
- 优缺点：
  - 在周转时间上，SRT比SPF的性能更好（优）
  - 必须记录过去的服务时间，增加开销（缺）
  - 作业的估计运行时间不准确（缺）

**$\color{red}{优先级调度算法}$**

- **$\color{red}{非抢占式优先级算法}$**

  - 主要用于批处理系统中，也可用于对实时性要求不高的实时系统

- **$\color{red}{抢占式优先级算法}$**

  - 较好的满足紧迫作业的要求，常用于要求较严格的实时系统和性能要求较高的分时和批处理系统

- **优先级的确定方法**

  - **进程类型**
    - **系统进程高于一般用户进程的优先权**
  - **进程对资源的要求**
    - **对CPU和内存要求少、运行时间短的优先权高些**
  - **用户要求**
    - 根据用户紧迫程度和用户所付费用决定

- **$\color{red}{静态优先级}$**

  - **进程创建时指定优先级，进程运行时，优先级不变**
  - **优点：**
    - 简单易行，系统开销小
  - **缺点：**
    - 不够精确，可能出现优先级低的作业或进程饥饿

- **$\color{red}{动态优先级}$**

  - **在进程创建时创建一个优先级，但在其生命周期内优先级可以动态变化**
  - 优先级确定方法：
    - 对于高度I/O密集型进程，因为需要大部分时间等待I/O，所以无论何时，只要需要CPU计算，即马上调度其执行，以尽快开始它的下次I/O请求，实现和其他进程的并发执行

- **$\color{red}{基于时间片的轮转调度算法（RR）}$**

  - **$\color{red}{RR的基本原理}$**
    - 把CPU划分为若干个时间片
    - 按顺序赋给FIFO就绪队列（先进先出）中的每个进程
    - 时间片耗尽时（时钟中断请求），即使进程未执行完成，也剥夺其CPU,将其排入**$\color{red}{就绪队列末尾}$**，同时选择队首进程运行
  - **$\color{red}{RR的进程切换时机}$**
    - 时间片内进程运行完成，立即激活进程调度程序
    - 时间片耗尽，计时器中断处理程序被激活（**$\color{red}{时钟中断请求}$**），剥夺当前进程CPU,送当前进程到**$\color{red}{就绪队列末尾}$**
  - **$\color{red}{时间片大小的确定}$**
    - 时间片大小对系统性能影响很大
    - 时间片过小，**$\color{red}{有利于短进程，但进程调度和切换频繁，增加系统开销}$**
    - 时间片过大，退化为FCFS，无法满足短作业和交互式进程的需求
    - 时间片**$\color{red}{可选取略大于一次典型交互的所需时间}$**

  | 作业名称 | 到达时间 | 运行时间 | 完成时间 | 周转时间 | 带权周转时间 |
  | -------- | -------- | -------- | -------- | -------- | ------------ |
  | A        | 0        | 10       | 30       | 30       | 3            |
  | B        | 0        | 6        | 23       | 23       | 3.83         |
  | C        | 0        | 2        | 8        | 8        | 4            |
  | D        | 0        | 4        | 17       | 17       | 4.25         |
  | E        | 0        | 8        | 28       | 28       | 3.5          |

  平均带权周转时间：3.716

- **$\color{red}{多级反馈队列调度算法}$**

  ![](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221206135110488.png)

  - 将**$\color{red}{就绪队列分为N级}$**，级别越高，时间片越短，级别越低，时间片越长

  - 进程**$\color{red}{第一次就绪}$**时，进入第一级队列队尾，按FCFS原则等待调度。系统从第一级队列调度，当第一级为空时，转向第二级队列，……
  - 当前进程用完一个时间片，如果运行完成，则退出系统，否则必须放弃**$\color{red}{并插入下一级就绪队列队尾（阻塞进程被唤醒时，进入原来的就绪队列）}$**
  - **$\color{red}{如果CPU正在处理第i级队列时，有新进程加入第一级队列，或有新唤醒的进程比当前进程的队列级别高，则新进程抢占当前进程CPU,而原来的当前进程插入第i级队列队尾}$**
  - **特点**
    - **$\color{red}{终端型作业用户}$**（交互型作业，第一级队列的时间片可完成）
    - **$\color{red}{短批处理作业用户}$**（最多轮转两次就可完成，周转时间较短）
    - **$\color{red}{长批处理作业用户}$**（不必担心长期得不到调度，比简单轮转性能好）

  ![](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221206143113051.png)

![](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221206143326528.png)

- **调度机制**
  - 调度算法一旦固定，则其最优、最坏情况均无法避免
- **调度策略**
  - 为用户提供改变调整调度机制的渠道
  - 实现方法——提供系统调用，能改变调度机制

- **$\color{red}{分时系统中进程调度算法通常采用}$ $\color{green}{时间片轮转算法}$**
- **$\color{red}{UNIX系统中，进程调度采用的技术是}$ $\color{green}{动态优先数}$**

### 实时调度

**实时系统例子：**实验控制、过程控制设备、机器人、空中交通管制、远程通信、军事指挥与控制系统、自动驾驶系统等

**实现实时调度的基本条件**

- **提供必要的信息**

  - 开始 / 完成截止时间
  - 就绪时间
  - 处理时间
  - 资源要求
  - 优先级

- **系统处理能力强**

  - 如：系统中有m个**$\color{red}{周期性}$**的**$\color{red}{硬实时任务}$**，处理时间为C<sub>i</sub>，周期时间为P<sub>i</sub>（1 <= i < = m），单处理机下必须满足：
    $$
    \sum^{m}_{i = 1}\displaystyle \frac{C_{i}}{P_{i}} <= 1
    $$
    
  - **为多处理机（N个）时，限制条件变为：**
    $$
    \sum^{m}_{i = 1}\displaystyle \frac{C_{i}}{P_{i}} <= N
    $$
  
- 

- **采用抢占式调度机制（硬实时系统）**
- **具有快速切换机制**
  - 对外部中断的快速响应能力（要求快速**硬件**中断机制、允许中断的间隔短）
  - 快速的任务分配能力（系统中每个运行功能单位适当的小）

**实时调度算法的分类**

- **实时任务性质不同**
  - **硬实时调度算法**
  - **软实时调度算法**
- **调度方式不同**
  - **非抢占式调度算法**
    - **非抢占式轮转调度算法**
      - **应用于不太严格的实时控制系统，如工业生产的群控系统**
    - **非抢占式优先调度算法**
      - **当实时任务到达，放在就绪队列队首，等待当前任务的自我终止或运行完成$\color{red}{适用于较为严格的实时控制系统}$**
  - **抢占式调度算法**
    - **基于时钟中断的抢占式优先权调度算法**
      - **当优先级高于当前任务的实时任务到达，则等待下一个时钟中断，抢占当前任务的处理机$\color{red}{适用于较严格的实时系统}$**
    - **立即抢占的优先权调度算法**
      - 一旦出现请求中断的紧急任务，**只要当前任务未在临界区，立即抢占它的CPU**
       - 系统**必须具有快速相应外部中断能力**
- **调度时间不同**
  - **静态调度算法**
  - **动态调度算法**
- **多处理机情况下**
  - **集中式调度算法**
  - **分布式调度算法**
  - 


 **最早截止时间优先算法(EDF)**
 - 截止时间越早的任务，优先级越高，截止时间越晚的任务，优先级越低
 - 根据任务的开始截止时间来确定任务的优先级
 - **可用于抢占式调度和非抢占式调度**



 **最低松弛度优先算法（LLF）**

 - 根据任务的紧急（或松弛）程度确定任务的优先级
 - **松弛度=必须完成的时间-还需运行的时间-当前时间**
 - **松弛度是动态变化的**
 - 主要用于**可抢占式调度方式**
 - 当一任务的**最低松弛度为0时，必须立即抢占CPU**，以保证按截止时间的要求完成任务
 - 当**多个进程松弛度相同且为最小时**，**按照"最近最久未调度"的原则进行进程调度**



**紧密耦合MPS（多处理机系统）和松散耦合MPS**

- 紧密耦合MPS：通过高速总线或高速交叉开关，实现多个处理器间的互连，它们共享存储器和I/O设备
- 松散耦合MPS：通过通道或通信线路，实现多台计算机间互连



**对称MPS和非对称MPS**

- 根据系统中所用处理器的相同与否划分：
  - 对称多处理系统（SMPS）：系统中所包含的处理器在**功能和结构上都是相同的**
  - 非对称多处理系统：系统中有多种类型的处理器单元，**一主多从**



**对称多处理系统**

- 把多处理器看成一个处理器池
- 静态分配方式：
  - 一个进程从开始执行直至其完成，都被固定地分配到一个处理器上去执行
  - 每个处理器设置一个专用的就绪队列
  - **问题：处理器会出现忙闲不均**
- 动态分配方式：
  - 设置一个公共的就绪队列，所有就绪进程都被放在该队列中，分配时可将进程分配到任一处理器
  - **优点：解决了各处理器的忙闲不均现象**
  - **缺点：对于松散耦合系统会增加系统开销**



**非对称多处理器系统**

- 主 / 从式分配方式
  - OS核心部分驻留在主机，从机只是用户程序，进程调度由主机完成
  - 每当从机空闲，向主机发送索求进程信号，等待主机为它分配进程
  - **优点：系统处理比较简单、不会出现处理器的闲忙不均现象**
  - **缺点：具有不可靠性**

**进程（线程）调度方式**

- **自调度方式**
  - 在系统中设置一个公共的进程或线程就绪队列，所有处理器在空闲时，可**自行**到该队列中取得一进程或线程来运行
  - 采用但处理器下使用的调度算法，如FCFS
  - **优点：**
    - 系统中的公共就绪队列可按单处理机系统所采用的各种方式加以组织
    - 调度算法可用单处理机系统所用的算法
    - 只要有任务就不会出现处理机空闲的情况
  - **缺点：**
    - **瓶颈问题、低效性、线程切换频繁**
- **成组调度方式**
  - **将一进程中一组线程，分配到一组处理器上去执行**
  - **优点：**
    - 一组相互合作的进程或线程能并行执行，可有效地减少进程 / 线程阻塞情况的发生，从而减少线程的切换
    - 每次调度可解决一组线程的处理器分配问题，因而可显著减少调度的频率，从而减少调度开销。
  - **面向所有应用程序平均分配处理器时间**

     - 如系统中有N个处理器和M个应用程序，每个应用程序中至多含有N个线程，则每个应用程序至多可占有N个处理器的1/M时间
  - **面向所有线程平均分配处理器时间**

     - 如M个应用程序共有L个线程，则每个线程至多可占有N个处理器的1/L时间


   - **专用处理器分配方式**


      - 在一个应用程序执行期间，专为其分配一组处理器，每个线程一个处理器，改组处理器仅供该应用程序专用，直至该应用程序完成


      - 虽然会造成处理机的严重浪费，但在高度并行的系统，每个处理器的利用率不是十分重要


      - 在同时执行的多道应用程序中，其线程总数不应超过处理机数目

**实时调度算法的分类**


 - 按**任务性质**不同分为**硬实时调度算法**和**软实时调度算法**
 - 按**调度方式**分为**抢占式调度算法**和**非抢占式调度算法**
 - 按**调度时间**分为**静态调度算法**和**动态调度算法**


### 死锁的概念


 - 一组进程中每个进程都无限等待被改组进程中另一个进程所占有的资源，而处于的一种僵持局面，若无外力作用，它们都无法向前推进，这种现象称为进程死锁，这组进程就称为死锁进程

**死锁原因**


 - **竞争资源**引起进程死锁
 - 可剥夺和非可剥夺资源

   - **可剥夺资源：**进程在获得这个资源后可**被其他进程或系统剥夺**
   - **非可剥夺资源：**资源被系统分配给某个进程后**不能强行收回**，只能进程自己释放
 - 竞争**非可剥夺资源**

![image-20221207173319528](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207173319528.png)


 - **竞争资源引起进程死锁**


   - 竞争临时性资源（进程通信时）

   ![image-20221207173209684](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207173209684.png)
 - **进程推进顺序不当引起死锁**

![image-20221207173347503](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207173347503.png)

**死锁的必要条件**


- **互斥条件：**涉及到资源是**非共享**的
- **不可剥夺条件：不能剥夺进程拥有资源**
- **请求保持条件：**进程中**等待一新资源时继续占有已分配的资源**
- **环路条件：**存在一种进程的**循环链（循环等待链）**，链中每个进程已获得的资源同时被链中下一个进程请求


**预防死锁**


- 通过设置某些限制条件，去破坏死锁的四个必要条件中的一个或多个，来防止死锁


**避免死锁**


- 不事先采取限制去破坏产生死锁的条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁发生


**检测死锁**


- 检测方法

  - **每种类型一个资源**的死锁检测方法

    - **检测有向图是否存在环**
- 事先**不采取任何限制**，也不检查系统是否进入不安全区，**允许死锁发生**
- 但可通过检测机构及时检测死锁的发生，并精确确定与死锁有关的进程和资源，然后采取措施将已发生的死锁清除

**解除死锁**


- 与**死锁检测相配套**，用于将进程从死锁状态解脱出来
- 常用的方法是**撤销或挂起一些进程**，以回收一些资源，再将它们分配给处于阻塞状态的进程，使其转为**就绪态**

**鸵鸟算法**


- **忽略死锁**

### 死锁的预防

**破坏死锁的四个必要条件**

- **原理为：设计不同资源分配算法，保证不发生死锁
- **破坏互斥条件**
  - 如果资源不需要互斥访问，就可以破坏互斥条件
  - 对于某些硬件资源，可以采用特殊技术实现允许同时访问
  - 对于软件资源，无法实现
- **破坏请求和保持条件**
  - **在执行时不再提出资源请求**
  - 系统要求所有进程要**一次性**地申请在整个运行过程中所需的**全部资源**，若系统有足够资源则完全分配
  - **在等待时不保持任何资源**
  - 只要有一个请求的资源不可用，其他可用资源都不分配给它
  - **优点**：简单，易于实现且安全
  - **缺点**：**延迟运行、非常浪费**
- **破坏不可剥夺条件**
  - 一个已拥有资源的进程，**若它再提出新资源要求而不能立即得到满足时**，它**必须释放已经拥有的所有资源，以后需要时再重新申请**
  - 实现复杂，要**付出很大代价**
- **破坏环路条件**
  - 系统将所有资源按类型进行**线性排序**，并赋予不同的序号，所有进程对资源的请求必须严格按照资源序号**递增的次序**提出
  - **优点：资源利用率和系统吞吐量有较明显改善
  - **缺点：进程实际需要资源的顺序不一定与资源编号一致，因此仍会造成资源浪费
  - 资源序号必须相对稳定，限制了新设备的增加
- **预防死锁原理为设计不同资源分配算法**，来保证死锁不会发生
- **破坏请求和保持**的资源分配算法是一种**静态资源分配**
- **破坏不可剥夺条件和环路条件**是**动态分配资源算法**
- **破坏环路条件是相对优异的预防死锁算法**



### 死锁的避免

- 死锁避免

  - 在系统运行过程中，对进程提出的每一个（系统能满足的）资源申请进行动态检查（**安全性检查**）
  - 根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配，否则予以分配

- **安全状态**

  - 如果系统能按某种顺序为每个进程依次分配其所需资源，直至所有进程都能运行完成，称此时系统处于**安全状态**
  - 这种进程的顺序称为**安全序列**
  - 不存在这样的一个安全序列时称处于**不安全状态**
  - **$\color{red}{不安全状态不等于死锁}$**
    - **不安全状态的系统不一定发生死锁**
    - **安全状态的系统一定不会发生死锁**

- **$\color{red}{银行家算法}$**

  - **可利用资源向量 Available**

    ![image-20221207180413675](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207180413675.png)

  - **最大需求矩阵 Max**

    ![image-20221207180437718](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207180437718.png)

  - **分配矩阵 Allocation**

  ![](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207180453114.png)

  - **需求矩阵 Need**

  ![](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207181232325.png)

**Need[i,j] = Max[i,j] - Allocation[i,j]**

- **银行家算法的步骤：**

![image-20221207181133814](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207181133814.png)

**安全性算法**

![](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207181839710.png)

### 死锁的检测与解除

**$\color{red}{死锁检测：}$**

- 允许死锁发生，操作系统**不断监视**系统进展情况，判断死锁是否发生
- 一旦死锁发生，采取措施解除死锁，并以最小代价恢复系统运行

**$\color{red}{检测时机}$**

- 定时检测
- 当进程阻塞时检测死锁（缺点：系统开销大）
- 系统资源利用率下降时检测死锁

![](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207214328315.png)

![](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207214429883.png)![](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207214506196.png)

![](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207214853855.png)![](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207215507782.png)

### 存储器管理

![image-20221207222928935](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207222928935.png)

![image-20221207223038725](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207223038725.png)

![image-20221207223553026](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207223553026.png)

![image-20221207223710316](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207223710316.png)

![image-20221207223800965](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207223800965.png)

![image-20221207223823387](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207223823387.png)

![image-20221207223851567](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207223851567.png)

![image-20221207224039199](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207224039199.png)

![image-20221207224127903](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207224127903.png)

![image-20221207224359757](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207224359757.png)

![image-20221207224425305](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207224425305.png)

![image-20221207224630047](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207224630047.png)

![image-20221207224716100](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221207224716100.png)

![image-20221208001147293](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208001147293.png)

![](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208064007788.png)

![image-20221208064027790](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208064027790.png)

![image-20221208064036595](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208064036595.png)

![image-20221208064049008](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208064049008.png)

![image-20221208064104587](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208064104587.png)

![image-20221208064114603](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208064114603.png)

![image-20221208064122469](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208064122469.png)

![image-20221208064132512](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208064132512.png)

![image-20221208064140433](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208064140433.png)

![image-20221208064233878](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208064233878.png)

![image-20221208064305122](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208064305122.png)

![image-20221208064345870](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208064345870.png)

![image-20221208064438418](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208064438418.png)

![image-20221208064515914](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208064515914.png)

![image-20221208064535052](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208064535052.png)

**$\color{red}{在基本分页方案下，程序逻辑页的大小与内存块的大小相等}$**

![image-20221208065256067](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208065256067.png)

![image-20221208065328172](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208065328172.png)

![image-20221208065442746](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208065442746.png)

![image-20221208065622100](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208065622100.png)

![image-20221208070116708](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208070116708.png)

![image-20221208070844779](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208070844779.png)

**$\color{red}{在页式虚拟存储系统中，页面长度是固定并且是硬件的设计特性}$**

![image-20221208072455004](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208072455004.png)

![image-20221208072629117](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208072629117.png)

![image-20221208072715376](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208072715376.png)

![image-20221208072754964](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208072754964.png)

![image-20221208072855575](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208072855575.png)

![image-20221208072957095](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208072957095.png)

![image-20221208073148053](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208073148053.png)

![image-20221208073228002](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208073228002.png)

![image-20221208073258217](https://gitee.com/yelishu/note/raw/401a52b256c5814f4ac69565c595fbc121a5e263/noteImgs/image-20221208073258217.png)